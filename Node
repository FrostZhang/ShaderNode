Shader "Cus/Node"
{
	Properties
	{
		_MainTex ("Texture", 2D) = "white" {}
		_NormalMap ("Normal Map", 2D) = "white" {}
		_NormalStenth("Normal Stenth",float)=1

		_DissolveMap("DissolveMap",2D)="white"{}
	}
	SubShader
	{
		Cull Off /* Front Back */  ZWrite On ZTest Always /* Off LEqual */
		Tags {
				"RenderType" = "Opaque" /*"Transparent" "TransparentCutout" "Background" "Overlay"*/
				"Queue" = "Background" /* "Geometry" "AlphaTest" "Transparent" "Overlay"*/
			 }
		/*UsePass "name"*/
		LOD 300
		/* GrabPass {"_Mygrab"} */
		Pass
		{
			Tags{
					"LightMode" = "ForwardBase" /* "ForwardAdd" "Vertex" "VertexLit" "ShadowCaster" "ShadowCollector"*/
				}
			Fog {Mode Off}
			AlphaTest Off /*Less L/G/Not Equal[0.2] Greater[0.5] Never */
			Blend One Zero /* SrcAlpha OneMinusSrcAlpha */
			/* ColorMask R */
			/* Lighting On */
			/* Offset -1,-1 //Ouline*/
			Name "NODE"  //Capital
			Stencil{
						Ref 0 //0-255 
						ReadMask 255
						WriteMask 255
						Comp Equal
						Pass keep /* Keep Zero Replace IncrSat DecrSat Invert IncrWrap DecrWrap */
						Fail keep
						ZFail keep
					}

			CGPROGRAM
			#pragma vertex vert
			#pragma fragment frag
			/*# pragma target 3.0*/
			#include "UnityCG.cginc"
			#include "lighting.cginc"
			/*#include "Lighting.cginc"*/
			sampler2D _CameraDepthTexture;	
			sampler2D _CameraNormalsTexture;

			struct appdata
			{
				float4 vertex : POSITION;
				float4 uv : TEXCOORD0;
				float3 normal:NORMAL;
				float4 tangent:TANGENT;

			};

			struct v2f
			{
				float4 uv : TEXCOORD0;
				float4 vertex : SV_POSITION;
				fixed projector :COLOR;
				float4 screenPos  : TEXCOORD1;
				UNITY_FOG_COORDS(2)
			};
			sampler2D _MainTex;
			float4 _MainTex_ST;
			sampler2D _NormalMap;
			float _NormalStenth;
			float _Outline;
			float _Toon;
			float _RotarionSpeed;

			float4 DoRotation(float4 vertex)
			{
				float rotation = _RotarionSpeed * _Time.y;
				float s,c;
				sincos(radians(rotation),s,c);
				float2x2 rotMatrix = float2x2(c,-s,s,c);
				vertex.xy = mul(vertex.xy,rotMatrix);
				return vertex;
			}

			float4 DoScale(float4 vertex)
			{
				vertex.xz *= clamp((_SinTime.w + 3.0)*0.5, 1.0, 2.0);
				return vertex ;
			}

			float4x4 unity_Projector;
			float4x4 unity_ProjectorClip;
			v2f vert (appdata v)
			{
				v2f o;
				o.vertex = UnityObjectToClipPos(v.vertex);
			/*	float3 nor = mul((float3x3)UNITY_MATRIX_T_MV,v.normal);
				float2 offset = TransformViewToProjection(nor.xy);
				o.vertex.xy += offset * o.vertex.z * _Outline; //Ouline */

			/*	float4 ori =mul(UNITY_MATRIX_MV ,float(0,0,0,1));
				float4 vt = v.vertex;
				float2 r1 = float2(_Object2World[0][0],_Object2World[0][2]);
				float2 r2 = float2(_Object2World[2][0],_Object2World[2][2]);
				float2 vt0 = vt.x*r1;
				vt0 += vt.z *r2;
				vt.xy = vrt0;
				//vt.y= vt.z;
				vt.z=0;
				vt.xyz+=ori.xyz;
				o.vertex = mul(UNITY_MATRIX_P ,vt); //Billboard 公告板 */ 

				o.uv.xy = TRANSFORM_TEX(v.uv, _MainTex);

			    float3 lightdir = ObjSpaceLightDir(v.vertex);
				float lambert = saturate(dot (normalize(v.normal),normalize(lightdir)));
			 /*	lambert = （lambert+1） / 2;
				lambert = smoothstep(lambert/12,1,lambert); 
				float toon =floor(lambert *0.5)/0.5;
				lambert = lerp(lambert,toon,_Toon); //Catoon 卡通 */

				float3 reflectdir = reflect(-lightdir , v.normal);
				float3 viewdir = ObjSpaceViewDir(v.vertex);
				float reflectstrenth = saturate(dot(reflectdir,viewdir));
				float spec = pow(reflectstrenth,128);

				float3 halfview = normalize(lightdir + viewdir);
				float halflight = saturate(dot (normalize(halfview),normalize(lightdir)));
				float halfspec = pow(halflight , 128);

				float3 vertexlight = ShadeVertexLights(v.vertex ,v.normal);

				float3 worldnormal = UnityObjectToWorldNormal(v.normal);
				float3 lightprob = ShadeSH9(half4(worldnormal,1.0));

				#ifndef LIGHTMAP_OFF
				float2 lightmapuv =  o.uv.xy * unity_LightmapST.xy + unity_LightmapST.zw; 
				fixed3 lightmap = DecodeLightmap (UNITY_SAMPLE_TEX2D(unity_Lightmap, lightmapuv));
				#endif

				float3 pointLight = Shade4PointLights(unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
                    unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
                    unity_4LightAtten0,UnityObjectToWorldDir(o.vertex), UnityObjectToWorldNormal(v.normal));

				TANGENT_SPACE_ROTATION;
				float3 tangentlightdir = mul(rotation,lightdir);
				float3 tangennor = UnpackNormal( tex2D(_NormalMap,o.uv.xy));
				tangennor.xy *= _NormalStenth;

			/*	o.vertex =  mul(unity_Projector, v.vertex);
				float3 projectview = normalize(float3(float3(unity_Projector[2][0], unity_Projector[2][1], unity_Projector[2][2])));
				float proj = dot(v.normal,projectview);
				o.projector = proj < 0 ? 1 : 0; //projector 投影 */

				o.screenPos = ComputeScreenPos(o.vertex);
				COMPUTE_EYEDEPTH(o.screenPos.z); //depth 深度

				UNITY_TRANSFER_FOG(o,o.vertex);
				return o;
			}
			
			float4 _MainTex_TexelSize;
			float  _Dissolved;
			sampler2D _DissolveMap;

			fixed4 frag (v2f i) : SV_Target
			{
				fixed4 col = tex2D(_MainTex, i.uv);
				
				half lumin = Luminance(col);
				col = float4(lumin,lumin,lumin,col.a) ;  //Gray 灰度

				float4 uv[4];
				uv[0] = i.uv + float4(-_MainTex_TexelSize.x,-_MainTex_TexelSize.y,0,1);
				uv[1] = i.uv + float4(_MainTex_TexelSize.x,-_MainTex_TexelSize.y,0,1);
				uv[2] = i.uv + float4(_MainTex_TexelSize.x,_MainTex_TexelSize.y,0,1);
				uv[3] = i.uv + float4(-_MainTex_TexelSize.x,_MainTex_TexelSize.y,0,1);
				float4 c = tex2D(_MainTex, uv[0]);
				 c += tex2D(_MainTex, uv[1]);
				 c += tex2D(_MainTex, uv[2]);
				 c += tex2D(_MainTex, uv[3]);
				c/=4; //BlitMutilTap 模糊

			/*	fixed4 dissolvecolor = tex2D(_DissolveMap,i.uv);
				if(dissolvecolor.r< _Dissolved)
				{
					discard;
				}
				float prece = _Dissolved / dissolvecolor.r;
				float weight = saturate( sign(prece - 0.5));
				fixed3 edgrcol = lerp(dissolvecolor.rbg ,col.rbg ,weight);  //Dissolved 溶解 */

			    fixed4 projco = tex2Dproj(_MainTex, UNITY_PROJ_COORD(i.vertex));

				float depth = UNITY_SAMPLE_DEPTH(tex2D(_CameraDepthTexture ,i.uv));

				UNITY_APPLY_FOG(i.fogCoord, col);
				return col;
			}

			// col.a = min(1.0, col.a/abs(dot(viewdir , normal))); //GlowingEdges 边缘光
			// float rim = 1 - abs(dot(normal, normalize(viewDir))); //GlowingEdges 边缘光

			/*float sceneZ = LinearEyeDepth(SAMPLE_DEPTH_TEXTURE_PROJ(_CameraDepthTexture, UNITY_PROJ_COORD(i.screenPos)));
			float diff = sceneZ - i.screenPos.z;
			float intersect = (1 - diff) * _IntersectPower; //深度与物体深度对比得到轮廓*/
			ENDCG
		}

		/*Pass
		{
			ZTest Greater

			fixed4 frag (v2f i):SV_Target
			{
				return fixed4(1,0,0,1);
			}
		}
		Pass
		{
			ZTest Less 

			fixed4 frag (v2f i):SV_Target
			{
				return fixed4(1,1,0,1);
			}
		} //显示物体背后的物体 */
	}

	FallBack "Diffuse"
}
