//重映射
float Remap(float oldrangea,float oldrangeb,float newrangea,float newrangeb,float value)
{
	return (val-oa)/(ob-oa) * (nb-na) + na;
}
//角度转矩阵
float2x2 Rot2D(float a){a*= Radius2Deg; float sa = sin(a); float ca = cos(a); return float2x2(ca,-sa,sa,ca);}
float2x2 Rot2DRad(float a){float sa = sin(a); float ca = cos(a); return float2x2(ca,-sa,sa,ca);}


float3x3 Rotx(float a){a*= Radius2Deg; float sa = sin(a); float ca = cos(a); return float3x3(1.,.0,.0,    .0,ca,sa,   .0,-sa,ca);}
float3x3 Roty(float a){a*= Radius2Deg; float sa = sin(a); float ca = cos(a); return float3x3(ca,.0,sa,    .0,1.,.0,   -sa,.0,ca);}
float3x3 Rotz(float a){a*= Radius2Deg; float sa = sin(a); float ca = cos(a); return float3x3(ca,sa,.0,    -sa,ca,.0,  .0,.0,1.); }

float3x3 RotEuler(float3 ang) {
	ang = ang*Radius2Deg;
    float2 a1 = float2(sin(ang.x),cos(ang.x));
    float2 a2 = float2(sin(ang.y),cos(ang.y));
    float2 a3 = float2(sin(ang.z),cos(ang.z));
    float3x3 m;
    m[0] = float3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);
    m[1] = float3(-a2.y*a1.x,a1.y*a2.y,a2.x);
    m[2] = float3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);
    return m;
}
